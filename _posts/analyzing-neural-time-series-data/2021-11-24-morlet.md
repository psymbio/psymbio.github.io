---
layout: post
title: Morlet Wavelets
tag: Mike X Cohen Course
category: posts
order: 1
pagestyle: base
pagestyle2: post
---
## Morlet Wavelets (Usage and Python Implementation)

We might lose data while converting the signals of EEG from the time to frequency domain. That's a short-coming of static spectral analyses, and so to be able to extract frequency specific information over time we use wavelet convolution.

What's a wavelet?

<div class="wikipedia">
A wavelet is a wave-like oscillation with an amplitude that begins at zero, increases or decreases, and then returns to zero one or more times. Wavelets are termed a "brief oscillation". A taxonomy of wavelets has been established, based on the number and direction of its pulses. Wavelets are imbued with specific properties that make them useful for signal processing.
</div>

<iframe src="https://www.desmos.com/calculator/lbzmlosf4g" width="100%" style="min-height:400px"></iframe>

Yeah, there's a bit of cheating, we can't graph complex numbers in desmos and I'll probably have to look into plotting these another way, but for now the only online substitute is visit [this](https://jutanium.github.io/ComplexNumberGrapher/) and type this: $$\cos (2\pi z)+z\sin (2\pi z)$$ (from Euler's formula) and like all things complex, you must imagine yourself multiplying it with a gaussian and creating a morlet.

Euler's formula for the basic waves $$e^{2\pi i \theta}$$ is $$e^{2\pi i \theta} = cos(2\pi\theta) + i sin(2\pi\theta)$$.

The Arctic Monkeys logo might be more mathematic than you think.

<iframe src="https://www.desmos.com/calculator/uuv2ikwvev" width="100%" style="min-height:400px"></iframe>

„Åã„Çè„ÅÑ„ÅÑ„Åß„Åô„Å≠üíÆ

Requirements for a wavelet: it integrates to zero or the sum total is zero over time and it tapers to zero in the beginning and the end.

Wavelets provide temporal specificity when used as weighting functions for signals, as when these signals are convoluted(sliding dot product between the kernel and the section of signal it's aligned with) with the kernel(in this case the morlet wavelet).

<figure>
<img alt="separate signals" src="/images/2021/ants/multichannel.gif" height="80%" width="80%">
<figcaption align="center">Multi-channel Convolution</figcaption>
</figure>

So now, unlike weighting the signal with a normal sine wave, weighting with the morlet retains temporal information because it tapers out as well as the spectral information(something like a fourier transform, just better).

```python
import math
import numpy as np
import matplotlib.pyplot as plt
```


```python
srate = 1000
# changed time from [-1,1] to [-2,2] to get a better guassian resolution
time = np.linspace(start = -2, stop = 2, num = 1000)
freq = 2 * np.pi
```


```python
# using euler's to ceneter the sine at zero (it looks okay)
sine_wave = np.cos(2 * np.pi * freq * time) - 0.1 * np.sin(2 * np.pi * freq * time)
```


```python
plt.plot(time, sine_wave)
plt.title('Sine wave')
plt.xlabel('Time')
plt.ylabel('Amplitude')
plt.grid(True, which='both')
plt.axhline(y=0, color='k')
plt.show()
```



<figure><img alt="image_alt" src="/images/2021/ants/output_3_0.png" height="80%" width="80%"><figcaption align="center"></figcaption></figure>


We want to create a guassian with a full width at half maximum (FWHM), where the FWHM is the width of a line shape at half of its maximum amplitude, as shown below:

<figure><img alt="image_alt" src="/images/2021/ants/FWHM.svg" height="80%" width="80%"><figcaption align="center"></figcaption></figure>

```python
# defining the gaussian
# full width at half maximum
fwhm = 0.5
gaussian = np.exp((-4 * np.log(2) * (time)**2) / (fwhm**2))
```


```python
plt.plot(time, gaussian, 'y')
plt.title('Gaussian')
plt.xlabel('Time')
plt.ylabel('')
plt.grid(True, which='both')
plt.axhline(y=0, color='k')
plt.show()
```



<figure><img alt="image_alt" src="/images/2021/ants/output_6_0.png" height="80%" width="80%"><figcaption align="center"></figcaption></figure>



```python
# element-wise multiplication of the sine and gaussian
morlet_wavelet = sine_wave * gaussian
```


```python
# viola! a morlet
plt.plot(time, morlet_wavelet, 'g')
plt.title('Morlet Wavelet')
plt.xlabel('Time')
plt.ylabel('Amplitude')
plt.grid(True, which='both')
plt.axhline(y=0, color='k')
plt.show()
```



<figure><img alt="image_alt" src="/images/2021/ants/output_8_0.png" height="80%" width="80%"><figcaption align="center"></figcaption></figure>



```python
# looking at everything at once.
plt.plot(time, sine_wave)
plt.plot(time, gaussian, 'y')
plt.plot(time, morlet_wavelet, 'g')
plt.title('Morlet Wavelet')
plt.xlabel('Time')
plt.ylabel('Amplitude')
plt.grid(True, which='both')
plt.axhline(y=0, color='k')
plt.show()
```



<figure><img alt="image_alt" src="/images/2021/ants/output_9_0.png" height="80%" width="80%"><figcaption align="center"></figcaption></figure>



```python
pnts = time.shape[0]
mwX = 1.5 * abs(np.fft.fft(morlet_wavelet)/pnts)
hz = np.linspace(start = 0, stop = srate, num = pnts)
```


```python
plt.plot(hz, mwX, 'b')
plt.title('Morlet Wavelet')
plt.xlabel('Time')
plt.ylabel('Amplitude')
plt.grid(True, which='both')
plt.axhline(y=0, color='k')
plt.show()
```



<figure><img alt="image_alt" src="/images/2021/ants/output_11_0.png" height="80%" width="80%"><figcaption align="center"></figcaption></figure>



```python
# zoomed in version
plt.plot(hz, mwX, 'b')
plt.title('Morlet Wavelet')
plt.xlabel('Time')
plt.ylabel('Amplitude')
plt.grid(True, which='both')
plt.axhline(y=0, color='k')
plt.margins(x=0, y=-0.001)
plt.xlim(0,40)
plt.show()
```



<figure><img alt="image_alt" src="/images/2021/ants/output_12_0.png" height="80%" width="80%"><figcaption align="center"></figcaption></figure>


Links:

https://pythontic.com/visualization/charts/sinewave

[Convolution in one dimension for neural networks](https://e2eml.school/convolution_one_d.html)

[Dot-product kernels in ml](http://www.svcl.ucsd.edu/courses/ece271B-F09/handouts/DPK.pdf)

[Kernel Methods](https://www.dcs.bbk.ac.uk/~ale/dsta/dsta-2/dsta-2018-19-zaki-meira-ch5-excerpt-v2.pdf)
